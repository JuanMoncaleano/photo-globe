<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>My 3D Photo Globe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background: #0b0b0f; color: #eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    #globeCanvas { display: block; width: 100%; height: 100%; outline: none; }

    .ui {
      position: fixed; top: 12px; left: 12px; right: 12px; display: flex; gap: 10px; align-items: center; z-index: 10;
      pointer-events: none;
    }
    .ui-group {
      display: inline-flex; gap: 10px; align-items: center; pointer-events: auto;
      background: rgba(15, 15, 22, 0.55); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px; padding: 8px 10px; box-shadow: 0 6px 20px rgba(0,0,0,0.35);
    }
    button {
      appearance: none; border: none; border-radius: 10px; padding: 10px 14px; font-weight: 600; letter-spacing: 0.2px;
      background: #3b82f6; color: white; cursor: pointer; transition: transform 0.08s ease, filter 0.15s ease, background 0.2s ease;
    }
    button:hover { filter: brightness(1.06); }
    button:active { transform: translateY(1px); }
    #hint { opacity: 0.85; font-size: 14px; }
    .badge {
      font-size: 12px; opacity: 0.8; padding: 4px 8px; border-radius: 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08);
    }

    .overlay {
      position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,0.6);
      opacity: 0; pointer-events: none; transition: opacity 120ms ease; z-index: 20;
    }
    .overlay.show { opacity: 1; pointer-events: auto; }
    .overlay-content {
      max-width: min(92vw, 1200px); max-height: 92vh; position: relative;
      background: rgba(20,20,24,0.6); border: 1px solid rgba(255,255,255,0.08); backdrop-filter: blur(12px);
      border-radius: 14px; padding: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .overlay-content img {
      display: block; width: 100%; height: auto; max-height: calc(92vh - 24px); object-fit: contain; border-radius: 10px;
    }
    .overlay .close {
      position: absolute; top: 8px; right: 8px; width: 40px; height: 40px; border-radius: 10px; font-size: 24px; line-height: 24px;
      color: #eaeaea; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.1); cursor: pointer;
    }

    #toast {
      position: fixed; left: 50%; bottom: 24px; transform: translateX(-50%);
      background: rgba(20,20,28,0.75); border: 1px solid rgba(255,255,255,0.1);
      color: #f1f5f9; padding: 10px 14px; border-radius: 10px; z-index: 15; box-shadow: 0 10px 30px rgba(0,0,0,0.45);
      opacity: 0; pointer-events: none; transition: opacity 140ms ease;
    }
    #toast.show { opacity: 1; }

    /* Lightweight spinner while textures load */
    #loading {
      position: fixed; top: 12px; right: 12px; z-index: 11; font-size: 12px; opacity: 0.85;
      background: rgba(15, 15, 22, 0.55); border: 1px solid rgba(255,255,255,0.08); padding: 6px 10px; border-radius: 10px;
    }
    @media (max-width: 520px) { #hint { display: none; } }
  </style>
</head>
<body>
  <canvas id="globeCanvas" aria-label="Interactive 3D globe"></canvas>

  <div class="ui">
    <div class="ui-group">
      <button id="uploadBtn" title="Upload a photo to drop a pin">Upload photo</button>
      <span id="hint">After uploading, click the globe to place your pin. Click a pin to view your photo.</span>
      <span class="badge">one photo per pin</span>
    </div>
  </div>

  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="overlay-content" role="dialog" aria-modal="true" aria-label="Photo viewer">
      <button class="close" title="Close">&times;</button>
      <img id="overlayImg" alt="Your uploaded photo" />
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite"></div>
  <div id="loading" hidden>Loading texturesâ€¦</div>

  <!-- Hidden input so we can style the button; capture lets phones open camera too -->
  <input id="fileInput" type="file" accept="image/*" capture="environment" hidden />

  <!-- Direct module imports (no import map). This path works well on GitHub Pages & mobile. -->
  <script type="module">
    const THREE_CDN = 'https://cdn.jsdelivr.net/npm/three@0.160.0';
    import * as THREE from `${THREE_CDN}/build/three.module.js`;
    import { OrbitControls } from `${THREE_CDN}/examples/jsm/controls/OrbitControls.js`;

    // --------- DOM ----------
    const canvas = document.getElementById('globeCanvas');
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');
    const overlay = document.getElementById('overlay');
    const overlayImg = document.getElementById('overlayImg');
    const overlayClose = overlay.querySelector('.close');
    const toast = document.getElementById('toast');
    const loading = document.getElementById('loading');

    function showToast(msg, ms = 1800) {
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.classList.remove('show'), ms);
    }

    // --------- THREE Setup ----------
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0b0b0f, 1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.4, 2.2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.rotateSpeed = 0.45;
    controls.zoomSpeed = 0.8;
    controls.minDistance = 1.3;
    controls.maxDistance = 5.5;
    controls.enablePan = false;
    controls.target.set(0, 0, 0);

    // Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.65);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(5, 3, 2);
    scene.add(dir);

    // Earth (starts visible in solid color, then upgrades to textures)
    const EARTH_RADIUS = 1.0;
    const earthGeom = new THREE.SphereGeometry(EARTH_RADIUS, 96, 96);
    const earthMat = new THREE.MeshPhongMaterial({
      color: 0x6ea8ff,          // visible immediately
      shininess: 6,
      specular: new THREE.Color(0x222222)
    });
    const earth = new THREE.Mesh(earthGeom, earthMat);
    scene.add(earth);

    // Markers container
    const markers = new THREE.Group();
    scene.add(markers);

    // Raycaster
    const raycaster = new THREE.Raycaster();
    const pointerNDC = new THREE.Vector2();

    function updatePointerNDC(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointerNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointerNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    }

    // Coordinate helpers
    function latLonToVec3(latDeg, lonDeg, radius = EARTH_RADIUS) {
      const lat = THREE.MathUtils.degToRad(latDeg);
      const lon = THREE.MathUtils.degToRad(lonDeg);
      const x = radius * Math.cos(lat) * Math.cos(lon);
      const z = radius * Math.cos(lat) * Math.sin(lon);
      const y = radius * Math.sin(lat);
      return new THREE.Vector3(x, y, z);
    }
    function vec3ToLatLon(vec) {
      const v = vec.clone().normalize();
      const lat = THREE.MathUtils.radToDeg(Math.asin(v.y));
      const lon = THREE.MathUtils.radToDeg(Math.atan2(v.z, v.x));
      return { lat, lon };
    }

    // Placement / viewing state
    let placing = false;
    let pendingImageURL = null;

    // Upload flow
    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      e.target.value = ''; // allow re-upload of same file later
      if (!file) return;
      const url = await fileToDataURL(file);
      pendingImageURL = url;
      placing = true;
      document.body.style.cursor = 'crosshair';
      showToast('Click the globe where you want your photo.');
    });

    function fileToDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // Create a pin (small bright sphere)
    function addMarker(lat, lon, imageURL) {
      const pos = latLonToVec3(lat, lon, EARTH_RADIUS + 0.01);
      const geom = new THREE.SphereGeometry(0.018, 18, 18);
      const mat = new THREE.MeshBasicMaterial({ color: 0xff3b5c });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.copy(pos);
      mesh.userData = { lat, lon, imageURL };
      markers.add(mesh);
      return mesh;
    }

    // Fly-to animation
    let flight = null;
    function flyTo(lat, lon, distance = 2.1, ms = 900) {
      const toTarget = latLonToVec3(lat, lon, EARTH_RADIUS);
      const toCam = toTarget.clone().setLength(distance);

      flight = {
        start: performance.now(),
        dur: ms,
        fromPos: camera.position.clone(),
        toPos: toCam,
        fromTgt: controls.target.clone(),
        toTgt: toTarget
      };
    }

    // Interaction
    renderer.domElement.addEventListener('pointerdown', (e) => {
      updatePointerNDC(e);
      raycaster.setFromCamera(pointerNDC, camera);

      if (placing) {
        const hit = raycaster.intersectObject(earth, false)[0];
        if (hit) {
          const pointOnSurface = hit.point.clone().normalize().multiplyScalar(EARTH_RADIUS);
          const { lat, lon } = vec3ToLatLon(pointOnSurface);
          addMarker(lat, lon, pendingImageURL);
          flyTo(lat, lon);
          placing = false;
          pendingImageURL = null;
          document.body.style.cursor = '';
          showToast('Pinned! Click the dot to view your photo.', 1600);
        }
        return;
      }

      // Not placing: check for marker click
      const mHit = raycaster.intersectObjects(markers.children, true)[0];
      if (mHit) {
        const { lat, lon, imageURL } = mHit.object.userData;
        flyTo(lat, lon, 2.0, 650);
        openOverlay(imageURL);
      }
    });

    // Hover feedback (desktop)
    renderer.domElement.addEventListener('pointermove', (e) => {
      updatePointerNDC(e);
      raycaster.setFromCamera(pointerNDC, camera);
      if (placing) {
        renderer.domElement.style.cursor = 'crosshair';
        return;
      }
      const mHit = raycaster.intersectObjects(markers.children, true)[0];
      renderer.domElement.style.cursor = mHit ? 'pointer' : '';
    });

    // Overlay controls
    function openOverlay(imgURL) {
      overlayImg.src = imgURL;
      overlay.classList.add('show');
      overlay.setAttribute('aria-hidden', 'false');
    }
    function closeOverlay() {
      overlay.classList.remove('show');
      overlay.setAttribute('aria-hidden', 'true');
      overlayImg.src = '';
    }
    overlay.addEventListener('click', (e) => { if (e.target === overlay) closeOverlay(); });
    overlayClose.addEventListener('click', closeOverlay);
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (placing) {
          placing = false; pendingImageURL = null; document.body.style.cursor = '';
          showToast('Placement canceled.', 1200);
        } else if (overlay.classList.contains('show')) {
          closeOverlay();
        }
      }
    });

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      earth.rotation.y += 0.0005; // gentle spin
      if (flight) {
        const t = Math.min(1, (performance.now() - flight.start) / flight.dur);
        const ease = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
        camera.position.lerpVectors(flight.fromPos, flight.toPos, ease);
        controls.target.lerpVectors(flight.fromTgt, flight.toTgt, ease);
        if (t >= 1) flight = null;
      }
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    // --- Texture loading with graceful fallback ---
    const texLoader = new THREE.TextureLoader();
    texLoader.setCrossOrigin('anonymous'); // help CORS from CDNs

    async function loadEarthTextures() {
      loading.hidden = false;
      const base = `${THREE_CDN}/examples/textures/planets`;
      try {
        const dayTex = await loadTexture(`${base}/earth_atmos_2048.jpg`, true);
        const bumpTex = await loadTexture(`${base}/earth_bump_2048.jpg`, false);

        earthMat.map = dayTex;
        earthMat.bumpMap = bumpTex;
        earthMat.bumpScale = 0.035;
        earthMat.color = new THREE.Color(0xffffff); // use texture colors
        earthMat.needsUpdate = true;
      } catch (err) {
        console.warn('Texture load failed, staying in solid-color mode.', err);
        showToast('Using fallback colors (texture server blocked).', 2200);
      } finally {
        loading.hidden = true;
      }
    }

    function loadTexture(url, srgb) {
      return new Promise((resolve, reject) => {
        texLoader.load(
          url,
          (tex) => {
            if (srgb) tex.colorSpace = THREE.SRGBColorSpace;
            resolve(tex);
          },
          undefined,
          (err) => reject(err)
        );
      });
    }

    loadEarthTextures();

    // WebGL heads-up
    if (!renderer.getContext()) {
      showToast('WebGL not available in this browser.', 3000);
    }
  </script>
</body>
</html>
